#!/usr/bin/env /usr/local/bin/python

import pkg_resources

pkg_resources.require("PyYAML>=5.1.1")

import os
import re
import sys
import yaml
import zlib
import shutil
import base64
import subprocess

from secret import secret
from config import config


def find_file(f: str) -> str:
    """ if file is in current dir, return it, else return it from the PWD.
        Why? Kustomize changes directory, but leaves PWD alone. This allows
        us to have secrets.enc.yaml in the kustomization dir, or deploy
        dir
    """
    try:
        os.stat(f)
        return f
    except FileNotFoundError:
        return os.path.join(os.environ["PWD"], f)


def sops_fetch(cfg: dict, keys: list) -> tuple:
    sops = shutil.which(
        "sops", path="/bin:/usr/bin:/snap/bin:%s/go/bin" % os.path.expanduser("~")
    )
    if not sops:
        print("Error in SecretTransformer: sops not on path", file=sys.stderr)
        sys.exit(1)

    if "secret_source" not in cfg:
        cfg["secret_source"] = "secrets.enc.yaml"

    sfile = find_file(cfg.get("secret_source"))

    try:
        with subprocess.Popen([sops, "-d", sfile], stdout=subprocess.PIPE) as f:
            secrets = yaml.safe_load(f.stdout)
    except subprocess.CalledProcessError as exc:
        print(
            "Is your secret-file %s in %s dir?" % (cfg["secret_source"], os.getcwd()),
            file=sys.stderr,
        )
        print(f"Error calling sops: {exc}", file=sys.stderr)
        sys.exit(1)

    if not secrets:
        print("Error: secrets is empty", file=sys.stderr)
        sys.exit(1)

    # if we have a keys list then the user want specific keys
    # dont use the * filter because why? if they dont want secrets then they dont refer to it
    if keys:
        for key in list(secrets):
            if key not in keys:
                secrets.pop(key)

    hash_v = 0
    # raise Exception(f"{secrets} difficult to debug")
    for k, v in secrets.items():
        v = str(v)  # :( convert all to str
        hash_v = hash_v ^ zlib.adler32(bytes(v, "utf-8"))
    hash_v = int(hash_v / 10000000) + int(hash_v % 10000000)

    return secrets, hash_v


#
# Main start
#
with open(sys.argv[1], "r") as stream:
    try:
        cfg = yaml.safe_load(stream)
    except yaml.YAMLError as exc:
        print("Error parsing SecretGenerator input (%s)", file=sys.stderr)
        sys.exit(1)

if "type" not in cfg:
    cfg["type"] = "Secret"

#
# get the sops decoded values
#
secrets, cfg["hash"] = sops_fetch(cfg, cfg.get("secrets", []))


if cfg.get("type") == "Secret":
    secret = yaml.safe_load(secret.format(cfg=cfg))

    secretType = cfg.get("secretType", "stringdata").lower()

    if secretType not in ("stringData", "data"):
        raise Exception(
            f"You need to specify a secretType: stringData|data is currently {cfg.get('secretType')}"
        )

    if secretType == "stringdata":
        secret["stringData"] = secrets

    if secretType == "data":
        # remove the placeholder
        if not secret.get("stringData"):
            secret.pop("stringData")

        # convert all values to strings :(
        for k, v in secrets.items():
            if type(v) is not type(str):
                secrets[k] = str(v)

        # base64 encode the values
        secrets.update(
            (k, base64.b64encode(bytes(v, "utf-8"))) for k, v in secrets.items()
        )
        secret["data"] = secrets

    obj = secret

elif cfg.get("type") == "ConfigMap":
    config = yaml.safe_load(config.format(cfg=cfg))
    config["data"] = secrets
    obj = config

else:
    print("Error: type must be one of Secret|ConfigMap", file=sys.stderr)
    sys.exit(-1)

if "namespace" in cfg["metadata"]:
    obj["metadata"]["namespace"] = cfg["metadata"]["namespace"]

print("---")
print(yaml.dump(obj, default_flow_style=False))
